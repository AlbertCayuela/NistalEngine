# NistalEngine
Nistal Engine is a 3D Engine created in the third year of our Videogame Design and Development degree. It's mainly created using OPEN-GL.
In our Engine you will find an audio system too, that allows you to control audio sources, audio listeners, etc. We used Wwise system for the audio part.

You can check our GitHub repository here: https://github.com/AlbertCayuela/NistalEngine

### Version
Nistal Engine v.1.0

[![NISTAL ENGINE](https://img.youtube.com/vi/S8jmj7fV04c/0.jpg)](https://www.youtube.com/watch?v=S8jmj7fV04c)

## Core Sub-Systems
### 3D Renderer
Our engine has a module renderer that handles all the drawing of the program. We don’t use shaders. Instead we use OpenGL Vertex Arrays with indices (except for the debug draw of the primitives which are rendered in direct mode). Everything is drawn in the post update of the module. There, the gameobjects are filtered and we only render the ones that are inside the fustrum.

### Geometry Loader
When we detect a file in our Assets/Models/ directory we read the file with Assimp and extract all the information we need (vertices, indices, uvs, name…) in order to render the mesh on screen. Then we save the resource in our own binary format.

### Mouse Picking
Mouse picking is done using the Raycast method. When the left mouse button is clicked, the camera module calculates a ray that will start in the corresponding clicked point in the near plane and will project until it reaches the far plane.

### GameObjects System
Gameobjects have a tree structure so the transformations affect all the children correctly. Each gameobject has a transform component and if it has a mesh, we calculate its AABB so that it can be filtered by the frustum culling or the quadtree.

### Data Serialization
Our engine serializes the entire hierarchy of objects scene through all the gameobjects and their corresponding components. For this we use UUIDs (Universally unique identifier) to be able to handle all the information when serializing and deserializing a scene. For our engine the UUIDs are generated by random numbers of 32 bits.

When using the engine, one of the most important features for the user is to be able of saving the scene in the computer. By doing this the user can save all his work to continue later and share it with other people.

### Binary Files Format
All assets in Assets/ are saved as resources in our own binary format inside the Library directory. Doing this we only save the data we need and when we have to read the process is easier and much faster than if we had to read the original asset file such as .fbx or .png. A new resource in our own binary format is generated each time we detect a new assets in Assets/.

Our engine accepts the following assets formats:

- Meshes: FBX.
- Textures: png, jpg, jpeg, dds and tga.

### 3D Camera & Frustum Culling
Our engine has two cameras: the editor camera (which can be controlled as in any other 3D software) and the game camera. The game camera is treated as a component of the gameobject ‘Main Camera’ and has frusutm culling using a quadtree so gameobjects outisde its frustum won’t be drawn.

### Importer 
Once the user adds a new mesh to the scene we store it in our own file format. By doing this we acomplish great performance when loading scenes, for example when loading a level.

### Time Management & Game Mode
When the engine is in game mode, the scene is seen though the game camera (which has frustum culling). We also keep an internal game clock (aside from the app clock) that will only run when the game mode is activated. Its dt will be passed to all the updates instead of the real time dt from the app.

User can play, pause and tick and even modify the speed of the time in game. To manAge all of the time propierties we have a time manager to set the time in all levels of the engine.

### User Interface
We have used the ImGui library for our Engine UI. We have been able to do all the menus, hierarchy window, buttons and texts. It has helped us with all the Engine UI options

## Controls
### General controls
- ESC: Quit
### Camera controls
- Movement: RightClick + WASD keys
- Pan / Zoom: Mouse wheel
- LeftAlt + LeftClick: Orbit around object
- F: Focus
- SHIFT: Duplicates movement speed
- RightClick + E: move camera up
- RightClick + R: move camera down

## Instructions to execute
1. Download the latest release from: https://github.com/AlbertCayuela/NistalEngine/releases
2. Unzip de file
3. Execute Nistal Engine.exe

## Team Members

<img height="450" src="https://github.com/AlbertCayuela/NistalEngine/blob/master/Team/AlbertCayuela.jpeg?raw=true"/>

### - Albert Cayuela: https://github.com/AlbertCayuela
- Hierarchy
- Time Manager
- Game Objects System
- Inspector
- Audio Part
- Frustum Culling
- Camera Component
- Mouse Picking
- Textures Loading

<img height="450" src="https://github.com/AlbertCayuela/NistalEngine/blob/master/Team/NadineGuti%C3%A9rrez.jpg?raw=true"/>

### - Nadine Gutiérrez: https://github.com/Nadine044
- Serialization
- Json Integration
- Save & Load Scenes
- Inspector
- Load FBX data (vertices, normals, textures...)
- Own File Format
- Parent/Unparent GameObjects

## Tools Used
- Visual Studio 2019
- OpenGL
- Assimp
- SDL
- Glew
- DeviL
- ImGui
- MathGeoLib
- Parson
- PhysFS

### License
MIT License

Copyright (c) 2020 Albert Cayuela & Nadine Gutiérrez

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
